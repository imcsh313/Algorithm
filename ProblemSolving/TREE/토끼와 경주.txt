https://www.codetree.ai/training-field/frequent-problems/problems/rabit-and-race

Q번의 명령

(priority_queue) rabbit {이동 횟수, {행 + 열, 행, 열}, id, 점수}
[취소 - 메모리 소모가 너무 커] rabbitDistance[id] = 거리 는 따로 관리 (3)함수
map<int, disScr> rabbitDisScr (id, {dis, score})
[취소] (pq) moving_rabbit - 정렬은 반대로 + moving rabbit은 id가 안 겹....칠 이유가 없네? + pq일 이유도 없네..?
[vector moving_rabbit -> 마지막에 정렬] => 이렇게 할 수 있는 방법은 없나..? 없겠지 ㅎㅎ
vector moving_rabbit -> 완전탐색
moving_rabbit 초기화
점수 추가 할 때, 움직인 토끼만 빼고 -> 최종에 더하기
더할 점수 저장
최종 위치는 나머지 계산으로 구할 수 있으면 좋을 것 같은데... (격자의 끝)

(1) 최초 1회, {100 N M P pid_1 d_1 pid_2 d_2 ... pid_p d_p}
[2 <= N, M <= 100,000]
[1 <= P <= 2,000]
[1 <= pid <= 10,000,000]
[1 <= d <= 1,000,000,000]
P마리의 토끼 -> 고유 번호 pid_i, 이동해야 하는 거리 d_i
모든 토끼는 처음에는 (1행, 1열)에 있음.
N * M의 격자에서 경주

(2) 최대 2000번, {200 K S}
[1 <= K <= min(100, P)]
[1 <= S <= 1,000,000]
{우선 순위가 높은 토끼 선별 -> 이동} K번 반복 (같은 토끼 여러 번 선택 가능)
우선 순위 1. 가장 적게 뛴 토끼
	2. 현재 (행 + 열)이 가장 작은 토끼
	3. 행이 가장 작은 토끼
	4. 열이 가장 작은 토끼
	5. 고유 번호가 작은 토끼
우선 순위가 가장 높은 토끼 선별 후, 상하좌우 4방향으로 d_i만큼 이동했을 때의 위치 구함
if) 격자를 벗어나게 된다면 반대 방향으로 이동
4개의 위치 중, 1. (행 + 열)이 가장 큰 위치
	2. 행 번호가 큰 위치
	3. 열 번호가 큰 위치 로 이동
이동하지 않은 모든 토끼(P - 1)에게 (행 + 열)의 점수 부여
K회의 이동이 모두 종료된 이후, 이동한 토끼 중,
1. 현재 (행 + 열)이 가장 큰 토끼
2. 행이 큰 토끼
3. 열이 큰 토끼
4. 고유 번호가 큰 토끼 에게 S 점수 부여 

(3) 최대 2000번, {300 pid_t L}
[1 <= L <= 1,000,000,000]
pid_t인 토끼의 이동거리를 L배
단, 이동거리는 10억(1,000,000,000) 이하

(4) 마지막 1회, {400}
모든 토끼중 가장 높은 점수 출력
